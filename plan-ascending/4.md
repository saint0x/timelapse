# Phase 4: CLI & Daemon

## Status: 60% Complete ✓

**Completed:**
- ✅ Foundation: Dependencies, utilities, lock management
- ✅ IPC infrastructure: Unix socket communication with bincode protocol
- ✅ Daemon lifecycle: Event loop, watcher integration, signal handling
- ✅ Commands: init, info, status, start, stop
- ✅ Binary builds and runs successfully

**Remaining:**
- ⏳ Commands: log, pin, unpin, diff, gc, restore
- ⏳ Daemon logging to file
- ⏳ JJ integration (lower priority)

---

## CLI Structure

- [x] Create `crates/cli/Cargo.toml`
  - [x] Dependencies: clap, tokio, tracing, tracing-subscriber, indicatif, owo-colors, nix, serde, bincode
  - [x] Add all timelapse crates as workspace dependencies
  - [x] Binary target: `[[bin]] name = "tl"`

- [x] Implement `main.rs`: CLI entry point
  - [x] clap Parser with all commands
  - [x] Tokio async main
  - [x] Command dispatching

- [x] Implement main function
  - [x] Initialize tracing subscriber
  - [x] Parse CLI arguments
  - [x] Dispatch to command handlers
  - [x] Handle errors gracefully (user-friendly messages)

## Command: `tl init`

- [x] Implement `cmd/init.rs` ✓ (from Phase 1)
  - [ ] `pub async fn run() -> Result<()>`
    ```rust
    // 1. Check if already initialized (.tl/ exists)
    // 2. Create .tl/ directory structure
    // 3. Initialize store (Store::init())
    // 4. Create initial checkpoint (empty tree)
    // 5. Optionally start daemon
    // 6. Print success message with next steps
    ```

- [ ] Create `.tl/config.toml` with defaults
  ```toml
  [retention]
  dense_count = 2000
  dense_window = "24h"

  [watcher]
  debounce_duration = "300ms"
  batch_size = 100
  buffer_size = 8192

  [daemon]
  auto_start = false
  ```

- [ ] Initialize empty tree checkpoint
  - [ ] Root tree: empty (no entries)
  - [ ] Reason: `Manual`
  - [ ] Set as HEAD

## Command: `tl status` ✓

- [x] Implement `cmd/status.rs` ✓
  - [x] Checks daemon status via is_running()
  - [x] Queries IPC for live daemon stats (PID, uptime, checkpoints created, watched paths)
  - [x] Displays latest checkpoint with full details
  - [x] Shows storage summary (checkpoint count, total size)
  - [x] Helpful tips based on repository state

- [x] Display format ✓
  - [x] Repository path
  - [x] Daemon: Running ✓ (PID, uptime, stats) or Not running (with tip)
  - [x] Latest checkpoint: ID, time (relative + absolute), files, reason, changed paths
  - [x] Storage: checkpoint count, total size

- [x] Use `owo-colors` for colored output ✓
  - [x] Green: daemon running with ✓
  - [x] Yellow: daemon not running
  - [x] Cyan: repository path, checkpoint IDs
  - [x] Dimmed: hints and secondary info

## Command: `tl log`

- [ ] Implement `cmd/log.rs`
  - [ ] `pub async fn run(limit: usize, since: Option<String>) -> Result<()>`
    ```rust
    // 1. Load journal
    // 2. Query checkpoints (last N or since timestamp)
    // 3. For each checkpoint:
    //    - Load tree and compute diff summary
    //    - Display: ID, time, reason, files changed
    ```

- [ ] Display format
  ```
  01HQZX... 2 minutes ago  [fs_batch]  3 files changed
    M  src/main.rs
    A  src/new.rs
    D  src/old.rs

  01HQZY... 5 minutes ago  [manual]    1 file changed
    M  README.md
  ```

- [ ] Implement diff summary
  - [ ] Compare checkpoint tree with parent tree
  - [ ] `TreeDiff { added, removed, modified }`
  - [ ] Use symbols: `A` = added, `D` = deleted, `M` = modified

- [ ] Add filtering options
  - [ ] `--limit N`: show last N checkpoints (default: 20)
  - [ ] `--since <time>`: show checkpoints since timestamp
  - [ ] `--path <path>`: show only checkpoints touching path

## Command: `tl diff`

- [ ] Implement `cmd/diff.rs`
  - [ ] `pub async fn run(a: String, b: String) -> Result<()>`
    ```rust
    // 1. Parse checkpoint IDs (a, b)
    // 2. Load trees for both checkpoints
    // 3. Compute tree diff
    // 4. Display diff (unified diff format)
    ```

- [ ] Support diff targets
  - [ ] Checkpoint ID: `01HQZX...`
  - [ ] Named pin: `last-good`
  - [ ] Relative: `HEAD~3`
  - [ ] Time: `@1h` (1 hour ago)

- [ ] Display unified diff
  - [ ] For each changed file:
    ```
    diff --snap a/src/main.rs b/src/main.rs
    --- a/src/main.rs  (01HQZX...)
    +++ b/src/main.rs  (01HQZY...)
    @@ -10,3 +10,4 @@
     fn main() {
    -    println!("old");
    +    println!("new");
    +    println!("added");
     }
    ```

- [ ] Diff algorithm
  - [ ] Load blob contents for both versions
  - [ ] Use `similar` crate for text diff
  - [ ] Binary files: show size change only

## Command: `tl restore`

- [ ] Implement `cmd/restore.rs`
  - [ ] `pub async fn run(target: String, force: bool) -> Result<()>`
    ```rust
    // 1. Parse target checkpoint
    // 2. Confirm with user (unless --force)
    // 3. Load target tree
    // 4. Apply tree to working directory:
    //    - Delete files not in tree
    //    - Restore files from blobs
    //    - Set file modes correctly
    // 5. Create "restore" checkpoint (record this action)
    // 6. Update HEAD
    ```

- [ ] Implement working tree update
  - [ ] `restore_tree(tree: &Tree, repo_root: &Path) -> Result<()>`
    ```rust
    // For each entry in tree:
    //   - Read blob from store
    //   - Write to working directory
    //   - Set mode (permissions, executable bit)
    //   - Handle symlinks
    // For files in working dir not in tree:
    //   - Delete (with confirmation or --force)
    ```

- [ ] Safety checks
  - [ ] Warn if uncommitted changes exist
  - [ ] Require `--force` to overwrite local changes
  - [ ] Never touch `.tl/` or `.git/`

- [ ] Progress indicator
  - [ ] Use `indicatif` for progress bar
  - [ ] Show: `Restoring files... [====>    ] 1234/5678`

## Command: `tl pin` / `tl unpin`

- [ ] Implement `cmd/pin.rs`
  - [ ] `pub async fn pin(id: String, name: String) -> Result<()>`
    ```rust
    // 1. Parse checkpoint ID
    // 2. Verify checkpoint exists
    // 3. Create pin file: .tl/refs/pins/<name>
    // 4. Write checkpoint ID to file
    ```
  - [ ] `pub async fn unpin(name: String) -> Result<()>`
    ```rust
    // 1. Delete .tl/refs/pins/<name>
    ```
  - [ ] `pub async fn list_pins() -> Result<()>`
    ```rust
    // 1. List all files in .tl/refs/pins/
    // 2. Display: name, checkpoint ID, creation time
    ```

- [ ] Built-in pins (auto-created)
  - [ ] `last-good`: updated manually by user
  - [ ] `pre-push`: created before `tl push`

## Command: `tl gc`

- [ ] Implement `cmd/gc.rs`
  - [ ] `pub async fn run(dry_run: bool) -> Result<()>`
    ```rust
    // 1. Acquire GC lock (.tl/locks/gc.lock)
    // 2. Run GC algorithm (from journal)
    // 3. Display stats: checkpoints removed, space freed
    // 4. If --dry-run: show what would be deleted
    ```

- [ ] Display format
  ```
  GC completed:
    Checkpoints removed: 234
    Blobs deleted: 567
    Trees deleted: 123
    Space freed: 12.3 MB
  ```

- [ ] Progress indicator
  - [ ] Show phases: "Marking live objects...", "Sweeping dead objects..."

## Daemon Management ✓

- [x] Implement `daemon.rs`: Background watcher daemon ✓
  - [x] Full Daemon struct with Arc<Store>, Arc<Journal>, Watcher, PathMap
  - [x] IPC server integration
  - [x] Shutdown coordination via broadcast channels

- [x] Implement daemon lifecycle ✓
  - [x] `start() -> Result<()>` - Complete with lock acquisition, component initialization
  - [x] `stop() -> Result<()>` - IPC shutdown with 5s timeout
  - [x] `is_running() -> bool` - Lock + socket verification

- [x] Implement daemon main loop ✓
  - [x] tokio::select! with watcher, IPC, signals, periodic tasks
  - [x] Pending path accumulation with 5-second intervals
  - [x] Concurrent IPC connection handling (tokio::spawn per connection)
  - [x] SIGTERM/SIGINT signal handlers
  - [x] Graceful shutdown with final checkpoint flush

- [x] Implement checkpoint creation in daemon ✓
  - [x] Debounced: 5-second checkpoint intervals
  - [x] Incremental: uses incremental_update from journal crate
  - [x] PathMap persistence to .tl/state/pathmap.bin
  - [x] Watcher checkpoint marking for overflow recovery

## IPC Communication ✓

- [x] Implement `ipc.rs`: Daemon communication ✓
  - [x] Length-prefixed binary protocol (bincode)
  - [x] Unix socket at .tl/state/daemon.sock
  - [x] IpcRequest enum: GetStatus, GetHead, GetCheckpoint, Shutdown
  - [x] IpcResponse enum: Status(DaemonStatus), Head, Checkpoint, Ok, Error
  - [x] IpcClient with async methods (connect, send_request, get_status, shutdown)
  - [x] IpcServer with async accept and connection handling
  - [x] Socket permissions: 0600 (owner-only security)

- [ ] Unix socket location: `.tl/state/daemon.sock`

- [ ] Implement request/response protocol
  - [ ] Use serde + bincode for serialization
  - [ ] Simple framed protocol: `[length: u32][payload: bytes]`

- [ ] CLI uses IPC to query daemon
  - [ ] `tl status` → `GetStatus` request
  - [ ] `tl log` → query journal directly (no IPC needed)
  - [ ] `tl stop` → `Shutdown` request

## Daemon Lock Management ✓

- [x] Implement `locks.rs`: Lock file handling ✓
  - [x] DaemonLock struct with path and file
  - [x] LockContent with PID and timestamp (JSON serialized)
  - [x] Drop trait for automatic cleanup

- [x] `acquire() -> Result<DaemonLock>` ✓
  - [x] Exclusive lock via nix::fcntl::flock (non-blocking)
  - [x] Stale lock detection and automatic retry
  - [x] PID and timestamp written to lock file

- [x] `release()` ✓
  - [x] Removes lock file
  - [x] flock automatically released on file drop

- [x] Stale lock detection ✓
  - [x] Platform-specific process checking
  - [x] macOS: kill(pid, SIGUSR1) with ESRCH detection
  - [x] Linux: /proc/<pid> directory existence
  - [x] Unit tests included

## Command: `tl start` / `tl stop` ✓

- [x] Implement `cmd/start.rs` ✓
  - [x] `pub async fn run(foreground: bool) -> Result<()>`
  - [x] Foreground mode: calls daemon::start() directly
  - [x] Background mode: uses nohup + Command::spawn()

- [x] Implement background daemon spawn ✓
  - [x] Uses `nohup tl start --foreground` approach
  - [x] Redirects stdout/stderr to `.tl/logs/daemon.log`
  - [x] Verification: waits 500ms then checks is_running()

- [x] Implement `cmd/stop.rs` ✓
  - [x] Sends `Shutdown` IPC request via client
  - [x] Polls lock file removal with 5s timeout
  - [x] Reports success or timeout error

## Auto-start Integration (Optional for MVP)

- [ ] macOS: LaunchAgent
  - [ ] Generate `~/Library/LaunchAgents/com.snap.daemon.plist`
  - [ ] `launchctl load/unload`

- [ ] Linux: systemd user service
  - [ ] Generate `~/.config/systemd/user/snap-daemon.service`
  - [ ] `systemctl --user enable/disable snap-daemon`

- [ ] **Decision**: Manual start for MVP
  - [ ] User runs `tl start` explicitly
  - [ ] Auto-start is optional enhancement

## Logging & Metrics

- [ ] Implement structured logging
  - [ ] Use `tracing` for all log output
  - [ ] Levels: ERROR, WARN, INFO, DEBUG, TRACE
  - [ ] Format: `[timestamp] [level] [target] message`

- [ ] Daemon logs to `.tl/logs/daemon.log`
  - [ ] Rotate logs (keep last 5 files, max 10MB each)
  - [ ] Log: checkpoint creation, errors, watcher events

- [ ] CLI logs to stderr (colorized)
  - [ ] User-facing messages (not debug logs)

- [ ] Metrics collection
  - [ ] Write to `.tl/state/metrics.json`
  - [ ] Track: checkpoints/hour, bytes written, errors
  - [ ] Use for `tl status` display

## Testing

- [ ] Unit tests for CLI parsing
  - [ ] Test all commands parse correctly
  - [ ] Test argument validation

- [ ] Integration tests for daemon
  - [ ] Start daemon, verify it's running
  - [ ] Stop daemon, verify clean shutdown
  - [ ] Test IPC communication

- [ ] Integration tests for restore
  - [ ] Create checkpoint, modify files, restore
  - [ ] Verify working tree matches checkpoint exactly

- [ ] End-to-end test
  - [ ] `tl init` → `tl start` → make changes → `tl log` → `tl restore`

## Memory Optimization

- [ ] CLI: Minimal startup overhead
  - [ ] Lazy load: only load components for active command
  - [ ] Target: < 50ms startup time

- [ ] Daemon: Long-lived process optimization
  - [ ] No per-checkpoint allocation (reuse buffers)
  - [ ] Target: < 40MB resident (includes watcher + journal + store)

## User Experience Polish

- [ ] Error messages
  - [ ] User-friendly errors (not raw Rust backtraces)
  - [ ] Suggestions: "Did you mean `tl init`?"

- [ ] Progress indicators
  - [ ] Use `indicatif` for long operations (restore, GC)
  - [ ] Show: current file, percentage, ETA

- [ ] Colors and formatting
  - [ ] Use `owo-colors` for terminal colors
  - [ ] Consistent formatting across commands
