# Phase 9: Native JJ Integration (100% jj-lib, Zero CLI)

## Status: ⏹️ NOT STARTED (0% Complete)

**Goal:** Replace all JJ CLI command invocations with native jj-lib API calls to achieve deep, nested integration throughout the codebase.

**Current State:**
- ✅ 20% Native: Workspace init, detection, loading (jj-lib APIs)
- ❌ 80% CLI Workaround: Publishing, workspace ops, git sync, file export (15+ CLI calls)
- ❌ 2 `todo!()` macros blocking native implementation

**Target State:**
- ✅ 100% Native: All JJ operations use jj-lib APIs
- ✅ Zero CLI calls: No `Command::new("jj")` anywhere in production code
- ✅ Full API integration: Direct access to JJ backend, working copy, views

**Estimated Scope:** ~45 hours (~6 days)
**Dependencies:** Phase 5 (current CLI-based JJ integration)
**Test Target:** 35+ new tests (24 existing + 11 new native API tests)

---

## Overview

Phase 5 implemented a **pragmatic CLI-based workaround** that works but lacks the deep integration we want. This phase converts everything to use jj-lib's native APIs for:

1. **Performance** - No process spawning overhead, direct in-memory operations
2. **Reliability** - No CLI output parsing, type-safe API contracts
3. **Features** - Access to advanced jj-lib features unavailable via CLI
4. **Control** - Fine-grained transaction management, custom merge strategies
5. **Integration** - Deep hooks into JJ's internal data structures

**Design Principle:** Use jj-lib APIs directly for all JJ operations. The JJ CLI is only for users, not for our code.

---

## Current CLI Usage Audit

### Files Using JJ CLI (6 files, 15+ calls)

1. **`crates/jj/src/publish.rs`** (3 calls)
   - Line 139: `jj commit -m` (publish checkpoint)
   - Line 151: `jj log --no-graph --limit 1 -T commit_id` (get commit ID)
   - Lines 478, 516, 613: Test setup with `jj git init`

2. **`crates/jj/src/workspace.rs`** (2 calls)
   - Line 139: `jj workspace list` (list workspaces)
   - Line 184: `jj status` (check workspace changes)

3. **`crates/jj/src/lib.rs`** (2 calls)
   - Line 184: `jj config set --repo` (configure bookmarks)
   - Line 206: `which jj` (binary detection)

4. **`crates/cli/src/cmd/publish.rs`** (1 call)
   - Line 107: `jj bookmark create` (create bookmark)

5. **`crates/cli/src/cmd/push.rs`** (1 call)
   - Line 52: `jj git push` (git push)

6. **`crates/cli/src/cmd/pull.rs`** (4 calls)
   - Line 25: `jj git fetch` (git fetch)
   - Line 159: `jj log -r @ -T commit_id --no-graph` (get HEAD)
   - Line 178: `jj file list` (list files)
   - Line 206: `jj file show` (export file content)

### `todo!()` Macros Blocking Native Implementation

1. **`crates/jj/src/materialize.rs:154`**
   ```rust
   pub fn convert_tree_to_jj(...) -> Result<jj_lib::backend::TreeId> {
       todo!("Implement convert_tree_to_jj - requires jj-lib integration")
   }
   ```

2. **`crates/jj/src/materialize.rs:177`**
   ```rust
   pub fn publish_checkpoint(...) -> Result<String> {
       todo!("Implement publish_checkpoint - requires jj-lib integration")
   }
   ```

---

## Phase Breakdown

### Task 9.1: Core Tree Conversion (High Priority - 8 hours)

**Goal:** Implement native Timelapse → JJ tree conversion using jj-lib backend APIs.

**Files Modified:**
- `crates/jj/src/materialize.rs` (+150 lines)

**Implementation Checklist:**

- [ ] **Remove `todo!()` at line 154: `convert_tree_to_jj()`**
  ```rust
  pub fn convert_tree_to_jj(
      tl_tree: &Tree,
      store: &Store,
      jj_backend: &dyn jj_lib::backend::Backend,
  ) -> Result<jj_lib::backend::TreeId> {
      // 1. Create JJ tree builder
      let mut tree_builder = jj_backend.empty_tree_builder();

      // 2. Iterate Timelapse tree entries
      for (path_bytes, entry) in tl_tree.entries_with_paths() {
          let path = std::str::from_utf8(path_bytes)?;

          // 3. Read blob content from Timelapse store
          let content = store.blob_store().read_blob(entry.blob_hash)?;

          // 4. Write blob to JJ backend
          let jj_file_id = jj_backend.write_file(&path.into(), &mut content.as_slice())?;

          // 5. Add to tree builder with proper TreeValue
          let tree_value = match entry.kind {
              EntryKind::File => {
                  if entry.mode & 0o111 != 0 {
                      TreeValue::Executable { id: jj_file_id }
                  } else {
                      TreeValue::File { id: jj_file_id, executable: false }
                  }
              }
              EntryKind::Symlink => TreeValue::Symlink { id: jj_file_id },
          };

          tree_builder.set(path.into(), tree_value);
      }

      // 6. Write tree and return ID
      let tree_id = tree_builder.write_tree()?;
      Ok(tree_id)
  }
  ```

- [ ] **Add TreeValue import** (`use jj_lib::backend::TreeValue;`)
- [ ] **Add comprehensive error handling** (blob read failures, path encoding)
- [ ] **Handle executable bit correctly** (mode & 0o111)
- [ ] **Handle symlinks** (TreeValue::Symlink)
- [ ] **Add path normalization** (ensure valid UTF-8, strip protected dirs)

**Test Coverage (5 tests):**

- [ ] `test_convert_tree_to_jj_empty_tree` - Empty tree conversion
- [ ] `test_convert_tree_to_jj_single_file` - Simple file
- [ ] `test_convert_tree_to_jj_executable` - Executable bit preserved
- [ ] `test_convert_tree_to_jj_symlink` - Symlink conversion
- [ ] `test_convert_tree_to_jj_nested_paths` - Deep directory structure

**Validation:**
- [ ] Tree hash matches for identical content
- [ ] Mode bits correctly transferred (644, 755, 120000)
- [ ] Symlink targets preserved
- [ ] Nested paths handled correctly

---

### Task 9.2: Native Checkpoint Publishing (High Priority - 10 hours)

**Goal:** Replace CLI-based `publish_checkpoint()` with native jj-lib transaction APIs.

**Files Modified:**
- `crates/jj/src/materialize.rs` (+200 lines)
- `crates/jj/src/publish.rs` (refactor -100 lines)

**Implementation Checklist:**

- [ ] **Remove `todo!()` at line 177: `publish_checkpoint()`**
  ```rust
  pub fn publish_checkpoint(
      checkpoint: &Checkpoint,
      store: &Store,
      workspace: &mut jj_lib::workspace::Workspace,
      mapping: &crate::mapping::JjMapping,
      options: &PublishOptions,
  ) -> Result<String> {
      // 1. Start transaction on workspace
      let mut tx = workspace.start_transaction(&user_settings, "publish checkpoint");
      let mut_repo = tx.mut_repo();

      // 2. Convert Timelapse tree to JJ tree
      let jj_backend = mut_repo.store().backend();
      let tree = store.read_tree(checkpoint.root_tree)?;
      let jj_tree_id = convert_tree_to_jj(&tree, store, jj_backend)?;

      // 3. Determine parent commits (from mapping or current @)
      let parent_ids = if let Some(parent_cp_id) = checkpoint.parent {
          if let Some(jj_commit_id) = mapping.get_jj_commit(parent_cp_id)? {
              vec![jj_commit_id]
          } else {
              // Parent not published, use current @
              vec![mut_repo.view().get_wc_commit_id(&workspace.workspace_id())?.clone()]
          }
      } else {
          // Root checkpoint, use empty parents
          vec![]
      };

      // 4. Build commit with CommitBuilder
      let commit_message = format_commit_message(checkpoint, &options.message_options);

      let commit = mut_repo.new_commit(
          &user_settings,
          parent_ids,
          jj_tree_id,
      )
      .set_description(commit_message)
      .write()?;

      let commit_id = commit.id().hex();

      // 5. Update working copy pointer
      mut_repo.set_wc_commit(&workspace.workspace_id(), commit.id().clone())?;

      // 6. Commit transaction
      tx.commit()?;

      // 7. Store bidirectional mapping
      mapping.set(checkpoint.id, &commit_id)?;
      mapping.set_reverse(&commit_id, checkpoint.id)?;

      // 8. Auto-pin if configured
      if let Some(pin_name) = &options.auto_pin {
          let pin_manager = PinManager::new(/* tl_dir */);
          pin_manager.pin(pin_name, checkpoint.id)?;
      }

      Ok(commit_id)
  }
  ```

- [ ] **Add transaction management** (start, commit, rollback on error)
- [ ] **Implement parent commit resolution** (use mapping, fallback to @)
- [ ] **Add commit timestamp preservation** (from checkpoint ULID)
- [ ] **Handle root checkpoints** (empty parent list)
- [ ] **Add author/committer metadata** (from config or defaults)
- [ ] **Update working copy pointer** (set_wc_commit)

**Refactor `publish.rs`:**

- [ ] **Delete `materialize_checkpoint_to_dir()` function** (no longer needed)
- [ ] **Delete `copy_dir_all()` function** (no longer needed)
- [ ] **Rewrite `publish_checkpoint()` to use native API** (call materialize.rs)
- [ ] **Remove tempfile dependency** (no temp dirs needed)
- [ ] **Remove all `Command::new("jj")` calls**
- [ ] **Update tests** (use jj-lib test utilities)

**Test Coverage (6 tests):**

- [ ] `test_publish_checkpoint_single` - Publish single checkpoint
- [ ] `test_publish_checkpoint_with_parent` - Parent commit linking
- [ ] `test_publish_checkpoint_root` - Root checkpoint (no parent)
- [ ] `test_publish_checkpoint_auto_pin` - Auto-pin functionality
- [ ] `test_publish_checkpoint_message_template` - Custom message template
- [ ] `test_publish_checkpoint_preserves_timestamp` - ULID timestamp → commit timestamp

**Validation:**
- [ ] Commit ID matches JJ's expectations
- [ ] Parent links correct
- [ ] Tree content identical to checkpoint
- [ ] Mapping stored correctly
- [ ] Working copy updated

---

### Task 9.3: Native Git Operations (Medium Priority - 8 hours)

**Goal:** Replace `jj git push` and `jj git fetch` with native jj-lib git APIs.

**Files Modified:**
- `crates/cli/src/cmd/push.rs` (refactor -50 lines, +80 lines)
- `crates/cli/src/cmd/pull.rs` (refactor -80 lines, +120 lines)
- `crates/jj/src/git.rs` (new file, +200 lines)

**Implementation Checklist:**

- [ ] **Create new module: `crates/jj/src/git.rs`**
  ```rust
  use anyhow::Result;
  use jj_lib::git::{import_refs, export_refs, fetch};
  use jj_lib::workspace::Workspace;

  pub fn push_to_remote(
      workspace: &mut Workspace,
      bookmark: Option<&str>,
      force: bool,
  ) -> Result<()> {
      let mut tx = workspace.start_transaction(/* ... */);
      let mut_repo = tx.mut_repo();

      // 1. Get git backend
      let git_repo = mut_repo.store().git_repo()
          .ok_or_else(|| anyhow!("Not a git-backed repository"))?;

      // 2. Export JJ refs to git
      export_refs(mut_repo)?;

      // 3. Build git push refspecs
      let refspecs = if let Some(bookmark_name) = bookmark {
          vec![format!("+refs/heads/snap/{}:refs/heads/snap/{}", bookmark_name, bookmark_name)]
      } else {
          vec!["refs/heads/*:refs/heads/*".to_string()]
      };

      // 4. Execute git push using git2
      let mut remote = git_repo.find_remote("origin")?;
      let mut push_options = git2::PushOptions::new();
      if force {
          // Set force push options
      }

      remote.push(&refspecs, Some(&mut push_options))?;

      tx.commit()?;
      Ok(())
  }

  pub fn fetch_from_remote(workspace: &mut Workspace) -> Result<()> {
      let mut tx = workspace.start_transaction(/* ... */);
      let mut_repo = tx.mut_repo();

      // 1. Get git backend
      let git_repo = mut_repo.store().git_repo()
          .ok_or_else(|| anyhow!("Not a git-backed repository"))?;

      // 2. Execute git fetch using git2
      let mut remote = git_repo.find_remote("origin")?;
      let refspecs: Vec<String> = vec![];
      remote.fetch(&refspecs, None, None)?;

      // 3. Import new git refs to JJ
      import_refs(mut_repo, &git_repo)?;

      tx.commit()?;
      Ok(())
  }
  ```

- [ ] **Update `push.rs` to use native API**
  - [ ] Remove `Command::new("jj")` at line 52
  - [ ] Call `jj::git::push_to_remote()`
  - [ ] Add git2 error handling (authentication, network, conflicts)
  - [ ] Preserve existing error messages and user guidance

- [ ] **Update `pull.rs` to use native API**
  - [ ] Remove `Command::new("jj")` at line 25
  - [ ] Call `jj::git::fetch_from_remote()`
  - [ ] Add git2 error handling
  - [ ] Keep import_jj_head logic (now uses native APIs)

- [ ] **Add git2 dependency** to `crates/jj/Cargo.toml`
  ```toml
  git2 = "0.18"
  ```

**Test Coverage (4 tests):**

- [ ] `test_push_to_remote_single_bookmark` - Push specific bookmark
- [ ] `test_push_to_remote_all` - Push all bookmarks
- [ ] `test_fetch_from_remote` - Fetch and import refs
- [ ] `test_git_operations_error_handling` - Network failures, auth errors

**Validation:**
- [ ] Bookmarks pushed correctly
- [ ] Refs imported after fetch
- [ ] Error messages user-friendly
- [ ] Authentication handled

---

### Task 9.4: Native Workspace Operations (Medium Priority - 6 hours)

**Goal:** Replace workspace CLI calls with jj-lib workspace APIs.

**Files Modified:**
- `crates/jj/src/workspace.rs` (refactor -60 lines, +100 lines)

**Implementation Checklist:**

- [ ] **Rewrite `list_jj_workspaces()` using jj-lib APIs**
  ```rust
  pub fn list_jj_workspaces(&self) -> Result<Vec<JjWorkspace>> {
      // Load workspace using jj-lib
      let workspace = crate::load_workspace(&self.repo_root)?;
      let repo = workspace.repo_loader().load_at_head(&user_settings)?;

      // Get workspace IDs from repo view
      let view = repo.view();
      let mut workspaces = Vec::new();

      for (workspace_id, wc_commit_id) in view.wc_commit_ids() {
          // Get workspace path from .jj/workspaces/<id>/
          let workspace_path = self.repo_root.join(format!(".jj/workspaces/{}", workspace_id));

          let is_current = workspace_id == workspace.workspace_id();
          let has_changes = self.check_workspace_changes_native(&repo, wc_commit_id)?;

          workspaces.push(JjWorkspace {
              name: workspace_id.as_str().to_string(),
              path: workspace_path,
              is_current,
              has_changes,
          });
      }

      Ok(workspaces)
  }
  ```

- [ ] **Rewrite `check_workspace_changes()` using native APIs**
  ```rust
  fn check_workspace_changes_native(
      &self,
      repo: &jj_lib::repo::ReadonlyRepo,
      wc_commit_id: &jj_lib::backend::CommitId,
  ) -> Result<bool> {
      // Get working copy tree
      let wc_commit = repo.store().get_commit(wc_commit_id)?;
      let wc_tree_id = wc_commit.tree_id();

      // Compare with current filesystem state
      // Use jj-lib's working copy snapshot APIs
      let working_copy = /* ... load working copy ... */;
      let current_tree_id = working_copy.current_tree_id()?;

      // Trees differ = has changes
      Ok(wc_tree_id != current_tree_id)
  }
  ```

- [ ] **Remove CLI calls at lines 139 and 184**
- [ ] **Add proper error handling for workspace loading**
- [ ] **Handle edge cases** (deleted workspaces, corrupted state)

**Test Coverage (3 tests):**

- [ ] `test_list_jj_workspaces_native` - List multiple workspaces
- [ ] `test_list_jj_workspaces_current` - Identify current workspace
- [ ] `test_check_workspace_changes_native` - Detect uncommitted changes

**Validation:**
- [ ] Workspace list accurate
- [ ] Current workspace detected
- [ ] Change detection correct

---

### Task 9.5: Native File Export/Import (Medium Priority - 7 hours)

**Goal:** Replace `jj file list` and `jj file show` with jj-lib tree/blob APIs.

**Files Modified:**
- `crates/cli/src/cmd/pull.rs` (refactor -100 lines, +150 lines)
- `crates/jj/src/export.rs` (new file, +180 lines)

**Implementation Checklist:**

- [ ] **Create new module: `crates/jj/src/export.rs`**
  ```rust
  use anyhow::Result;
  use jj_lib::backend::{Backend, TreeId};
  use std::path::Path;

  pub fn export_jj_tree_to_dir(
      backend: &dyn Backend,
      tree_id: &TreeId,
      target_dir: &Path,
  ) -> Result<()> {
      // 1. Read tree from backend
      let tree = backend.read_tree(&RepoPath::root(), tree_id)?;

      // 2. Iterate tree entries
      for (path, value) in tree.entries() {
          match value {
              TreeValue::File { id, executable } => {
                  // Read file blob
                  let mut content = Vec::new();
                  backend.read_file(path, id)?.read_to_end(&mut content)?;

                  // Write to disk
                  let file_path = target_dir.join(path.as_internal_file_string());
                  if let Some(parent) = file_path.parent() {
                      fs::create_dir_all(parent)?;
                  }
                  fs::write(&file_path, content)?;

                  // Set permissions
                  if *executable {
                      #[cfg(unix)]
                      {
                          use std::os::unix::fs::PermissionsExt;
                          fs::set_permissions(&file_path, fs::Permissions::from_mode(0o755))?;
                      }
                  }
              }
              TreeValue::Symlink { id } => {
                  // Read symlink target
                  let mut target = Vec::new();
                  backend.read_file(path, id)?.read_to_end(&mut target)?;
                  let target_str = String::from_utf8(target)?;

                  // Create symlink
                  #[cfg(unix)]
                  {
                      let link_path = target_dir.join(path.as_internal_file_string());
                      std::os::unix::fs::symlink(target_str, link_path)?;
                  }
              }
              TreeValue::Tree { id } => {
                  // Recurse into subtree
                  export_jj_tree_to_dir(backend, id, target_dir)?;
              }
              _ => {
                  // Handle other tree value types
              }
          }
      }

      Ok(())
  }
  ```

- [ ] **Rewrite `import_jj_head()` in pull.rs**
  - [ ] Remove `get_jj_head_commit_id()` CLI call (line 159)
  - [ ] Use `workspace.repo_loader().load_at_head()` and `view.get_wc_commit_id()`
  - [ ] Remove `export_jj_commit_to_dir()` CLI calls (lines 178, 206)
  - [ ] Use `jj::export::export_jj_tree_to_dir()`

- [ ] **Add RepoPath handling** for path conversions
- [ ] **Handle tree recursion** for nested directories
- [ ] **Preserve symlinks and permissions**

**Test Coverage (4 tests):**

- [ ] `test_export_jj_tree_single_file` - Export simple file
- [ ] `test_export_jj_tree_nested` - Export nested directories
- [ ] `test_export_jj_tree_symlinks` - Export symlinks
- [ ] `test_export_jj_tree_preserves_mode` - Executable bit preserved

**Validation:**
- [ ] All files exported
- [ ] Symlinks correct
- [ ] Permissions preserved
- [ ] Nested paths handled

---

### Task 9.6: Native Bookmark Operations (Low Priority - 3 hours)

**Goal:** Replace `jj bookmark create` with jj-lib view APIs.

**Files Modified:**
- `crates/cli/src/cmd/publish.rs` (refactor -15 lines, +25 lines)
- `crates/jj/src/bookmarks.rs` (new file, +80 lines)

**Implementation Checklist:**

- [ ] **Create new module: `crates/jj/src/bookmarks.rs`**
  ```rust
  use anyhow::Result;
  use jj_lib::workspace::Workspace;
  use jj_lib::backend::CommitId;

  pub fn create_bookmark(
      workspace: &mut Workspace,
      bookmark_name: &str,
      commit_id: &CommitId,
  ) -> Result<()> {
      let mut tx = workspace.start_transaction(/* ... */);
      let mut_repo = tx.mut_repo();

      // Create bookmark pointing to commit
      mut_repo.set_local_branch(
          bookmark_name,
          RefTarget::Normal(commit_id.clone()),
      );

      tx.commit()?;
      Ok(())
  }
  ```

- [ ] **Update `publish.rs` to use native API**
  - [ ] Remove `Command::new("jj")` at line 107
  - [ ] Call `jj::bookmarks::create_bookmark()`
  - [ ] Add error handling for duplicate bookmarks

**Test Coverage (2 tests):**

- [ ] `test_create_bookmark_native` - Create new bookmark
- [ ] `test_create_bookmark_duplicate` - Handle duplicate names

**Validation:**
- [ ] Bookmark created
- [ ] Points to correct commit
- [ ] Duplicate detection works

---

### Task 9.7: Configuration Management (Low Priority - 3 hours)

**Goal:** Replace `jj config set` with native config file manipulation.

**Files Modified:**
- `crates/jj/src/lib.rs` (refactor -20 lines, +40 lines)

**Implementation Checklist:**

- [ ] **Rewrite `configure_jj_bookmarks()` using native file I/O**
  ```rust
  pub fn configure_jj_bookmarks(repo_root: &Path) -> Result<()> {
      let config_path = repo_root.join(".jj/repo/config.toml");

      // Read existing config
      let mut config = if config_path.exists() {
          let content = fs::read_to_string(&config_path)?;
          toml::from_str(&content)?
      } else {
          toml::Table::new()
      };

      // Update settings
      config.insert("revsets".to_string(), toml::Value::Table({
          let mut table = toml::Table::new();
          table.insert("log".to_string(), toml::Value::String("bookmarks() | @".to_string()));
          table
      }));

      config.insert("git".to_string(), toml::Value::Table({
          let mut table = toml::Table::new();
          table.insert("push-bookmark-prefix".to_string(), toml::Value::String("snap/".to_string()));
          table
      }));

      // Write atomically
      let content = toml::to_string_pretty(&config)?;
      let temp_path = config_path.with_extension("tmp");
      fs::write(&temp_path, content)?;
      fs::rename(temp_path, config_path)?;

      Ok(())
  }
  ```

- [ ] **Remove `Command::new("jj")` at line 184**
- [ ] **Add TOML parsing** (already in dependencies)
- [ ] **Add atomic write** (temp file + rename)

**Test Coverage (1 test):**

- [ ] `test_configure_jj_bookmarks_native` - Config file updated correctly

**Validation:**
- [ ] Config written correctly
- [ ] Atomic operation
- [ ] Valid TOML syntax

---

## Test Plan

### New Tests (11 total)

**materialize.rs** (5 tests):
1. `test_convert_tree_to_jj_empty_tree`
2. `test_convert_tree_to_jj_single_file`
3. `test_convert_tree_to_jj_executable`
4. `test_convert_tree_to_jj_symlink`
5. `test_convert_tree_to_jj_nested_paths`
6. `test_publish_checkpoint_single`
7. `test_publish_checkpoint_with_parent`
8. `test_publish_checkpoint_root`
9. `test_publish_checkpoint_auto_pin`
10. `test_publish_checkpoint_message_template`
11. `test_publish_checkpoint_preserves_timestamp`

**git.rs** (4 tests):
12. `test_push_to_remote_single_bookmark`
13. `test_push_to_remote_all`
14. `test_fetch_from_remote`
15. `test_git_operations_error_handling`

**workspace.rs** (3 tests):
16. `test_list_jj_workspaces_native`
17. `test_list_jj_workspaces_current`
18. `test_check_workspace_changes_native`

**export.rs** (4 tests):
19. `test_export_jj_tree_single_file`
20. `test_export_jj_tree_nested`
21. `test_export_jj_tree_symlinks`
22. `test_export_jj_tree_preserves_mode`

**bookmarks.rs** (2 tests):
23. `test_create_bookmark_native`
24. `test_create_bookmark_duplicate`

**lib.rs** (1 test):
25. `test_configure_jj_bookmarks_native`

### Updated Tests (24 existing)

**publish.rs** - Update all tests to use native APIs instead of CLI:
- Remove `jj git init` setup calls
- Use jj-lib test utilities (`TestWorkspace`, `TestRepo`)
- Update assertions to check jj-lib objects directly

### Integration Tests (2 new)

26. `test_native_publish_push_pull_cycle` - Full cycle using only native APIs
27. `test_native_workspace_switch_with_checkpoint` - Workspace ops + checkpoints

### Test Execution

```bash
# Run all JJ tests
cargo test -p jj --lib

# Run integration tests
cargo test -p cli --test '*'

# Run specific native tests
cargo test -p jj test_convert_tree_to_jj
cargo test -p jj test_publish_checkpoint
```

**Target:** 35 total JJ tests (24 existing + 11 new)
**Current:** 24 tests passing
**Expected:** 35+ tests passing

---

## Success Criteria

### Functional Requirements

- [ ] **Zero CLI calls in production code**
  - All `Command::new("jj")` removed from `src/` (tests can keep them)
  - No output parsing or shell command construction
  - No process spawning for JJ operations

- [ ] **All `todo!()` macros removed**
  - `materialize.rs:154` implemented
  - `materialize.rs:177` implemented

- [ ] **Native API usage for all operations**
  - Tree conversion: ✅ jj-lib TreeBuilder
  - Publishing: ✅ jj-lib CommitBuilder + Transaction
  - Git sync: ✅ jj-lib git module + git2
  - Workspaces: ✅ jj-lib workspace APIs
  - File export: ✅ jj-lib backend read APIs
  - Bookmarks: ✅ jj-lib view APIs
  - Config: ✅ Direct TOML manipulation

### Performance Requirements

- [ ] **Publishing faster than CLI** (no process spawn overhead)
  - CLI baseline: ~100-200ms per checkpoint
  - Native target: < 50ms per checkpoint

- [ ] **Workspace ops faster** (no CLI parsing)
  - CLI baseline: ~50-100ms for `jj workspace list`
  - Native target: < 20ms

### Code Quality Requirements

- [ ] **Type safety** - All JJ data structures use jj-lib types
- [ ] **Error handling** - No unwrap(), proper error propagation
- [ ] **Documentation** - All public functions documented
- [ ] **Test coverage** - 35+ tests passing (24 existing + 11 new)

### Integration Requirements

- [ ] **Backward compatible** - Existing checkpoints still publishable
- [ ] **Mapping preserved** - Bidirectional checkpoint ↔ commit mapping unchanged
- [ ] **CLI unchanged** - User-facing commands work identically

---

## Dependencies

### Cargo Dependencies

Add to `crates/jj/Cargo.toml`:

```toml
[dependencies]
# Git operations (new)
git2 = "0.18"

# Existing dependencies (already present)
jj-lib = { workspace = true }
tl_core = { path = "../core", package = "core" }
journal = { path = "../journal" }
anyhow = { workspace = true }
thiserror = { workspace = true }
sled = { workspace = true }
ulid = { workspace = true }
blake3 = { workspace = true }
config = "0.13"
tempfile = { workspace = true }  # Can be removed after Task 9.2
serde = { workspace = true }
bincode = { workspace = true }
walkdir = { workspace = true }
```

**New:** git2 (for native git push/fetch)
**Remove:** tempfile (after Task 9.2 removes temp directory usage)

### Phase Dependencies

- **Requires:** Phase 5 (current CLI-based JJ integration)
- **Blocks:** None (this is an internal refactoring)
- **Parallel:** Can run alongside other enhancements

---

## Migration Strategy

### Approach: Incremental Replacement

1. **Week 1:** Tasks 9.1-9.2 (Core tree + publishing) - 18 hours
2. **Week 2:** Tasks 9.3-9.4 (Git ops + workspaces) - 14 hours
3. **Week 3:** Tasks 9.5-9.7 (File export + bookmarks + config) - 13 hours

### Rollback Plan

If native implementation has issues:

1. Keep existing CLI-based code in `publish_cli.rs`
2. Feature flag: `use-native-jj` (default: true)
3. Fallback to CLI if native fails:
   ```rust
   if cfg!(feature = "use-native-jj") {
       publish_checkpoint_native(...)
   } else {
       publish_checkpoint_cli(...)
   }
   ```

### Testing Strategy

1. **Dual validation** - Run both CLI and native, compare results
2. **Progressive rollout** - Enable native per-operation (publish first, then push, etc.)
3. **Metrics** - Track success rates, performance, error types

---

## File Changes Summary

### New Files (3)

1. `crates/jj/src/git.rs` (+200 lines) - Native git push/fetch
2. `crates/jj/src/export.rs` (+180 lines) - JJ tree export
3. `crates/jj/src/bookmarks.rs` (+80 lines) - Bookmark management

### Modified Files (6)

1. `crates/jj/src/materialize.rs` (+350 lines, -4 todo!s) - Native tree conversion + publishing
2. `crates/jj/src/publish.rs` (-100 lines, refactored) - Use native APIs
3. `crates/jj/src/workspace.rs` (+100 lines, -60 lines) - Native workspace ops
4. `crates/cli/src/cmd/publish.rs` (+25 lines, -15 lines) - Native bookmarks
5. `crates/cli/src/cmd/push.rs` (+80 lines, -50 lines) - Native git push
6. `crates/cli/src/cmd/pull.rs` (+150 lines, -100 lines) - Native git fetch + export
7. `crates/jj/src/lib.rs` (+40 lines, -20 lines) - Native config

### Total LOC Change

- **Added:** ~1,185 lines
- **Removed:** ~345 lines
- **Net:** +840 lines (native implementations more explicit than CLI calls)

---

## Risk Assessment

### Low Risk

- ✅ **Tree conversion** - Well-defined jj-lib APIs (`TreeBuilder`)
- ✅ **Config management** - Simple TOML file I/O
- ✅ **Bookmarks** - Straightforward view API

### Medium Risk

- ⚠️ **Git operations** - Requires git2 crate, authentication handling
- ⚠️ **File export** - Tree recursion complexity, symlink edge cases

### High Risk

- ⚡ **Transaction management** - Must handle commit/rollback correctly
- ⚡ **Parent resolution** - Mapping failures could break commit chains

### Mitigation

1. **Comprehensive testing** - 35+ tests cover edge cases
2. **Dual validation** - Compare native vs CLI results
3. **Atomic operations** - Use jj-lib transactions for all mutations
4. **Error recovery** - Detailed error messages, rollback on failure

---

## Progress Tracking

### Completion Checklist

**Task 9.1: Core Tree Conversion** (8 hours)
- [ ] Remove `todo!()` at materialize.rs:154
- [ ] Implement `convert_tree_to_jj()`
- [ ] Add 5 unit tests
- [ ] Validate tree hash correctness

**Task 9.2: Native Publishing** (10 hours)
- [ ] Remove `todo!()` at materialize.rs:177
- [ ] Implement `publish_checkpoint()` with transactions
- [ ] Refactor publish.rs to use native API
- [ ] Add 6 unit tests
- [ ] Remove tempfile dependency

**Task 9.3: Git Operations** (8 hours)
- [ ] Create git.rs module
- [ ] Implement `push_to_remote()` and `fetch_from_remote()`
- [ ] Update push.rs and pull.rs
- [ ] Add 4 unit tests
- [ ] Add git2 dependency

**Task 9.4: Workspace Operations** (6 hours)
- [ ] Rewrite `list_jj_workspaces()` natively
- [ ] Rewrite `check_workspace_changes()` natively
- [ ] Remove CLI calls from workspace.rs
- [ ] Add 3 unit tests

**Task 9.5: File Export** (7 hours)
- [ ] Create export.rs module
- [ ] Implement `export_jj_tree_to_dir()`
- [ ] Update pull.rs to use native export
- [ ] Add 4 unit tests

**Task 9.6: Bookmarks** (3 hours)
- [ ] Create bookmarks.rs module
- [ ] Implement `create_bookmark()`
- [ ] Update publish.rs
- [ ] Add 2 unit tests

**Task 9.7: Configuration** (3 hours)
- [ ] Rewrite `configure_jj_bookmarks()` natively
- [ ] Add 1 unit test

**Total:** 45 hours (~6 days)

---

## Phase 9 Deliverables

Upon completion:

1. ✅ **Zero CLI calls** - All JJ operations use jj-lib APIs
2. ✅ **35+ tests passing** - Comprehensive native API coverage
3. ✅ **Performance improvement** - 2-4x faster than CLI approach
4. ✅ **Code quality** - Type-safe, documented, maintainable
5. ✅ **User-facing unchanged** - Same CLI commands, better internals

**Status after Phase 9:**
- Phase 5: ✅ 100% Complete (native jj-lib, not CLI)
- JJ Integration: ✅ 100% Native (deep, nested integration)
- Total Tests: 212+ (201 existing + 11 new JJ native tests)

This achieves the goal: **100% native JJ integration with zero CLI workarounds**.
